<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ドットタイマー</title>
  <style>
    :root{ --dot-size:40px; --gap:10px; }
    *{ box-sizing:border-box }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:"Rounded Mplus 1c","Hiragino Maru Gothic ProN",sans-serif;
      background:#fffbe6; color:#222;
      /* ← スクロールOKに */
      overflow:auto;
      padding: calc(env(safe-area-inset-top) + 8px) 12px calc(env(safe-area-inset-bottom) + 8px);
    }
    h1{ font-size:1.2rem; margin:0 0 8px; color:#d17b00; text-align:center }
    .bar{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center }
    label{ font-weight:600 }
    input[type=number]{
      font-size:1.1rem; width:110px; padding:8px 10px; border-radius:12px;
      border:2px solid #ffa726; text-align:center; background:#fff;
    }
    button{
      font-size:1.1rem; padding:10px 16px; border-radius:14px; border:0;
      background:#ff9800; color:#fff; cursor:pointer; box-shadow:2px 2px 4px rgba(0,0,0,.2)
    }
    button.secondary{ background:#8d6e63 }
    .status{ display:flex; justify-content:center; gap:12px; align-items:center;
             font-size:1.05rem; min-height:1.8em; text-align:center; margin:8px 0 12px }
    .done{ font-weight:700; color:#2e7d32; }

    /* ドット領域：スクロール可能に */
    .gridWrap{
      max-width:1000px; margin:0 auto;
      border-radius:12px; background:#fff7df; padding:12px;
      box-shadow: 0 2px 8px rgba(0,0,0,.06);
      max-height: 70vh;            /* 画面の7割高さに収めて、外はページスクロール */
      overflow:auto;               /* ← ここでスクロール可能 */
      scroll-behavior: smooth;     /* JSのscrollIntoViewと相性◎ */
    }
    .dots{
      display:grid;
      grid-template-columns: repeat(10, var(--dot-size));
      gap: var(--gap);
      justify-content:center;
    }
    .dot{
      width:var(--dot-size); height:var(--dot-size); border-radius:50%;
      background:#4caf50; border:2px solid #2e7d32;
      transition:opacity .2s, background .2s, border-color .2s;
    }
    .dot.hidden{ background:#cfd8dc; border-color:#90a4ae; opacity:0.75; }
    .dot:nth-child(10n+1){ outline:2px dashed rgba(0,0,0,0.15); outline-offset:-4px }

    @media (max-width:480px){
      :root{ --dot-size:28px; --gap:6px }
    }
    @media (prefers-reduced-motion: reduce){
      .dot{ transition:none !important; }
    }
  </style>
</head>
<body>
  <h1>ドットタイマー</h1>

  <div class="bar" role="radiogroup" aria-label="モード選択">
    <label><input type="radio" name="mode" value="down" checked> 減る（カウントダウン）</label>
    <label><input type="radio" name="mode" value="up"> ふえる（カウントアップ）</label>
  </div>

  <div class="bar">
    <label for="count">ドット数</label>
    <input id="count" type="number" min="1" max="3600" value="60" />
    <button id="start">▶スタート</button>
    <button id="pause" class="secondary">⏸一時停止</button>
    <button id="reset" class="secondary">🔄リセット</button>
  </div>

  <div class="status" aria-live="polite">
    <div><span id="label">残り</span>：<strong id="primaryNumber">60</strong></div>
    <div class="done" id="doneText"></div>
  </div>

  <div class="gridWrap" id="gridWrap">
    <div class="dots" id="dots" aria-label="ドット表示領域"></div>
  </div>

  <script>
    (function(){
      const dotsEl = document.getElementById('dots');
      const wrap = document.getElementById('gridWrap');
      const countInput = document.getElementById('count');
      const startBtn = document.getElementById('start');
      const pauseBtn = document.getElementById('pause');
      const resetBtn = document.getElementById('reset');
      const labelEl = document.getElementById('label');
      const primaryEl = document.getElementById('primaryNumber');
      const doneEl = document.getElementById('doneText');
      const modeRadios = document.querySelectorAll('input[name="mode"]');

      let total = clamp(parseInt(countInput.value,10) || 60);
      let mode = getMode();
      let timer = null;
      let nextIndex = (mode==='down') ? total-1 : 0;

      // WebAudio（3回ビープ）
      let audioCtx = null;
      function ensureAudio(){
        try{
          if(!audioCtx){
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if(Ctx) audioCtx = new Ctx();
          }
          audioCtx?.resume?.();
        }catch(e){}
      }

      function clamp(v){ return Math.max(1, Math.min(3600, v)); }
      function getMode(){ return (Array.from(modeRadios).find(r=>r.checked)?.value)||'down'; }

      function buildDots(n){
        dotsEl.innerHTML = '';
        const startHidden = (mode==='up');
        for(let i=0;i<n;i++){
          const el = document.createElement('span');
          el.className = 'dot' + (startHidden ? ' hidden' : '');
          el.setAttribute('data-index', i);
          dotsEl.appendChild(el);
        }
        if(mode==='down'){ labelEl.textContent='残りドット'; primaryEl.textContent=n; nextIndex=n-1; }
        else{ labelEl.textContent='経過ドット'; primaryEl.textContent=0; nextIndex=0; }
        doneEl.textContent = '';

        // 初期スクロール位置：次に変化するドットを見せる
        scrollToIndex(nextIndex, {instant:true});
      }

      // 進行に合わせて自動スクロール
      function scrollToIndex(idx, {instant=false}={}){
        const target = dotsEl.querySelector('.dot[data-index="'+idx+'"]');
        if(!target) return;
        // wrap（スクロールコンテナ）基準でnearestに
        target.scrollIntoView({block:'nearest', inline:'nearest', behavior: instant?'auto':'smooth'});
      }

      function tick(){
        if(mode==='down'){
          if(nextIndex<0){ stopTimer(); return; }
          const dot = dotsEl.querySelector('.dot[data-index="'+nextIndex+'"]');
          if(dot) dot.classList.add('hidden');
          nextIndex--;
          const remain = Math.max(0, nextIndex+1);
          primaryEl.textContent = remain;
          if(remain===0) finish();
          else scrollToIndex(nextIndex); // 次に変化する位置へ追従
        }else{
          if(nextIndex>=total){ stopTimer(); return; }
          const dot = dotsEl.querySelector('.dot[data-index="'+nextIndex+'"]');
          if(dot) dot.classList.remove('hidden');
          nextIndex++;
          const elapsed = Math.min(total, nextIndex);
          primaryEl.textContent = elapsed;
          if(elapsed>=total) finish();
          else scrollToIndex(nextIndex); // 次に変化する位置へ追従
        }
      }

      function startTimer(){
        if(timer) return;
        ensureAudio();
        // スタート時点でも現在のターゲットへ寄せる
        scrollToIndex(nextIndex);
        timer = setInterval(tick, 1000);
      }
      function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }

      function finish(){
        stopTimer();
        doneEl.textContent = 'おわり！';
        playAlarm3();
      }

      // 0.6秒間隔 × 3回ビープ
      function playAlarm3(){
        try{
          ensureAudio();
          if(!audioCtx) return;
          const now = audioCtx.currentTime;
          for(let i=0;i<3;i++){
            const t = now + i*0.6;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type='sine'; osc.frequency.value=880;
            gain.gain.setValueAtTime(0.0001, t);
            gain.gain.exponentialRampToValueAtTime(0.3, t+0.01);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(t); osc.stop(t+0.25);
          }
        }catch(e){ /* フォールバック不要なら黙ってOK */ }
      }

      // 操作
      startBtn.addEventListener('click', startTimer);
      pauseBtn.addEventListener('click', stopTimer);
      resetBtn.addEventListener('click', ()=>{
        stopTimer();
        total = clamp(parseInt(countInput.value,10)||60);
        mode = getMode();
        buildDots(total);
      });
      countInput.addEventListener('change', ()=>{
        total = clamp(parseInt(countInput.value,10)||1);
        countInput.value = total;
        mode = getMode();
        buildDots(total);
      });
      modeRadios.forEach(r => r.addEventListener('change', ()=>{
        mode = getMode();
        buildDots(total);
      }));
      window.addEventListener('keydown', (e)=>{
        if(e.code==='Space'){ e.preventDefault(); if(timer) stopTimer(); else startTimer(); }
      });

      // 初期化
      buildDots(total);
    })();
  </script>
</body>
</html>
